#!/usr/bin/env python3
import os, sys, socket
from datetime import datetime
from zipfile import ZipFile
from io import BytesIO
from Cryptodome.Cipher import AES

# Same Hardcoded Key as in tmp363.py
KEY = b'1234567890ABCDEFGHIJKLMNOPQRSTUV'
BLOCK_SIZE = AES.block_size

# For fixed size blocks, this appends bytes to reach block size. This unpads it
def pkcs7_unpad(data):
	padLen = data[-1]
	return data[:-padLen]

# Helper function that
#	- retrieves nonce, tag, and ciphertax 
#	- Performs decryption and verifies decryption 
# 	- Returns plaintext
def decrypt(data):
	iv, ct = data[:BLOCK_SIZE], data[BLOCK_SIZE:]
	cipher = AES.new(KEY, AES.MODE_CBC, iv)
	return pkcs7_unpad(cipher.decrypt(ct))
	
# Helper function that:
#	- Reads 4096 bytes from each client connection, and extends until no buffer is received
#	- Attempts to decrypt the received data
#	- Stores plaintext in directory using the current date and time with the ip address of victim
# 	- Decompresses the zipfile into the directory created
def handleClient(conn, addr):
	buf = bytearray()
	while True:
		chunk = conn.recv(4096)
		if not chunk:
			break
		buf.extend(chunk)
	
	plain = decrypt(bytes(buf))
	timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
	dirname = f"{timestamp}_{addr[0]}"
	os.makedirs(dirname, exist_ok=True)
	with ZipFile(BytesIO(plain)) as z:
		z.extractall(dirname)

# Main functino
#	- Parses command line arguments for server and port to run on
#	- Using socket, listens on the provided ip address and port for client connections
#	- Handles client connections one at a time
# 	- Listens and upon connection, calls handleClient helper function
#	- Passes the connection socket and address
#	- Once done, continues listening to other client connections
def main():
	if len(sys.argv) != 3:
		return -1 # Invalid usage, kill program
	
	bind_ip, port = sys.argv[1], int(sys.argv[2])
	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
		s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		s.bind((bind_ip, port))
		s.listen(1)
		while True:
			conn, addr = s.accept()
			with conn:
				handleClient(conn, addr)
		
# Run server363		
main()
	
